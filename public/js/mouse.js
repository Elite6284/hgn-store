const tools = { drawPath(t, e) { t.save(), t.beginPath(), e(), t.closePath(), t.restore() }, random(t, e, o) { let a = t + Math.random() * (e + (o ? 1 : 0) - t); return o ? parseInt(a) : a }, getVectorLength: (t, e) => Math.sqrt(Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2)), easing: (t, e, o, a, s) => o * ((t = t / a - 1) * t * t + 1) + e, cellEasing: (t, e, o, a, s) => o * (t /= a) * t * t * t + e }, doc = { height: 0, width: 0 }, plane = { xCell: 0, yCell: 0, cells: [] }, context = { plane: null, main: null }, mouse = { x: 0, y: 0, coords: { x: 0, y: 0 }, down: { state: !1, x: 0, y: 0 } }, cfg = { cell: 35, sectionWidth: 8, sectionHeight: 1, numberOffset: 5, shadowBlur: !0, bgColor: "#080a1c" }, ui = { plane: "#plane-canvas", main: "#main-canvas", textNodes: "[data-js=text]", social: "#social", mouse: "#mouse" }; class App { constructor() { this.state = { area: 0, time: Date.now(), lt: 0, planeProgress: 0, dotsProgress: 0, fadeInProgress: 0, textProgress: 0, stepOffset: 0, textOffset: 0, markupOffset: 0, glitches: [], animLines: [], animNumbers: [], tabIsActive: !0, planeIsDrawn: !1, mousePower: 0, textPixelData: [], text: {}, delta: 0, dlt: performance.now(), needRedraw: !0 }, this.bindNodes(), this.getDimensions(), mouse.x = doc.width / 2, mouse.y = doc.height / 2, this.start() } start() { this.initEvents(), this.canvasInit(), this.loop(), this.initCheckingInterval(), this.splitText() } splitText() { ui.textNodes.forEach((t => { const e = t.innerText; t.innerHTML = e.split("").reduce(((t, e) => t + `<span class="letter">${e}</span>`), "") })) } animateText() { ui.textNodes.forEach(((t, e) => { t.classList.add("active"); const o = t.querySelectorAll(".letter"), a = Math.round(o.length / 2) + 1; for (let t = 0; t < a; t++) { const [s, l] = [o[t], o[o.length - t]]; setTimeout((() => { s && s.classList.add("active"), l && l.classList.add("active"), t === a - 1 && e === ui.textNodes.length - 1 && (ui.social.classList.add("active"), ui.mouse.classList.add("active")) }), 100 * t) } })) } getDimensions() { doc.height = document.documentElement.clientHeight, doc.width = document.documentElement.clientWidth } updatePlane() { const { width: t, height: e } = doc, o = Math.round(t / cfg.cell), a = t / o; plane.xCell = t / a % 2 != 0 ? t / (t / a + 1) : a; const s = e / Math.round(o * (e / t)); plane.yCell = e / s % 2 != 0 ? e / (e / s + 1) : s, plane.cells = [Math.round(t / plane.xCell), Math.round(e / plane.yCell)], plane.xCenter = Math.round(plane.cells[1] / 2), plane.yCenter = Math.round(plane.cells[0] / 2), plane.centerCoords = [plane.yCenter * plane.xCell, plane.xCenter * plane.yCell] } bindNodes() { for (const t in ui) ui[t] = document.querySelectorAll(ui[t]), 1 === ui[t].length && (ui[t] = ui[t][0]) } canvasInit() { const t = "10px Montserrat", e = "round", o = "rgba(255,255,255,0.1)"; context.plane = ui.plane.getContext("2d"), context.plane.lineCap = e, context.plane.lineJoin = e, context.plane.font = t, context.plane.fillStyle = o, context.plane.strokeStyle = o, context.main = ui.main.getContext("2d"), context.main.lineCap = e, context.main.lineJoin = e, context.main.font = t, context.main.fillStyle = o, context.main.strokeStyle = o, this.getTextPixels() } initEvents() { window.addEventListener("resize", (t => { this.getDimensions(), this.resizeHandler(t) })), document.addEventListener("mousemove", (t => { mouse.x = t.clientX, mouse.y = t.clientY, mouse.coords = { x: (mouse.x / doc.width - .5) / .5, y: (mouse.y / doc.height - .5) / .5 * -1 } })), document.addEventListener("mousedown", (t => { mouse.down = { state: !0, x: t.clientX, y: t.clientY } })), document.addEventListener("mouseup", (t => { mouse.down.state = !1 })), document.addEventListener("contextmenu", (t => { t.preventDefault() })), this.resizeHandler() } resizeHandler(t) { const e = this.state; e.area = doc.width * doc.height / 1e6, ui.main.height = doc.height, ui.main.width = doc.width, ui.plane.height = doc.height, ui.plane.width = doc.width, this.updatePlane(), this.updateTextConfig(), e.planeIsDrawn && this.getTextPixels(), e.needRedraw = !0 } updateTextConfig() { this.state.text = { baseLine: "top", font: "800 170px Montserrat", value: "HGN" } } initCheckingInterval() { const t = this.state; setInterval((() => { t.tabIsActive = !(t.time <= t.lt), t.lt = t.time, t.needRedraw = !t.tabIsActive }), 100) } loop() { const t = () => { const e = context.main, o = this.state; o.time = Date.now(), e.clearRect(0, 0, doc.width, doc.height), this.updateState(), this.draw(), o.needRedraw && (o.needRedraw = !1), this.raf = requestAnimationFrame(t) }; t() } updateState() { const t = this.state, e = performance.now(); t.delta = e - t.dlt, t.dlt = e; const o = t.delta; mouse.down.state ? (t.mousePower += .001 * o, t.mousePower >= 1 && (t.mousePower = 1, ui.mouse.classList.remove("active"))) : (t.mousePower -= .001 * o, t.mousePower <= 0 && (t.mousePower = 0)); const a = tools.cellEasing(t.mousePower, 0, 1, 1); t.planeProgress >= .2 && (t.dotsProgress += 35e-5 * o, t.dotsProgress >= 1 && (t.dotsProgress = 1)), t.planeProgress += 35e-5 * o, t.planeProgress >= 1 && (t.planeProgress = 1), t.planeIsDrawn && (t.fadeInProgress += 15e-5 * o, t.fadeInProgress >= 1 && (t.fadeInProgress = 1), t.stepOffset += .002 * o + a * (.0035 * o), t.textOffset += 5e-5 * o + a * (.002 * o), t.markupOffset += 15e-5 * o + a * (35e-5 * o), t.textProgress += 5e-4 * o, t.textProgress >= 1 && (t.textProgress = 1)) } getTextPixels() { const t = context.main, e = this.state, { xCell: o, yCell: a } = plane; tools.drawPath(t, (() => { t.fillStyle = "white", t.textBaseline = e.text.baseLine, t.font = e.text.font; const o = e.text.value, s = (parseInt(t.font), t.measureText(o).width), l = doc.width / 2 - s / 2, n = 1.75 * a; t.fillText(o, l, n) })); const s = t.getImageData(0, 0, doc.width, doc.height).data; e.textPixelData = []; for (let t = 0; t < doc.height; t += 10)for (let o = 0; o < doc.width; o += 10) { 255 == s[4 * (o + t * doc.width) - 1] && e.textPixelData.push({ x: o, y: t, value: tools.random(0, 1, !0) }) } t.clearRect(0, 0, doc.width, doc.height) } drawText() { const { yCell: t } = plane, e = context.main, o = this.state, a = o.textOffset, s = tools.cellEasing(o.mousePower, 0, 1, 1), l = o.textPixelData.length; tools.drawPath(e, (() => { cfg.shadowBlur && (e.shadowColor = "rgba(255,255,255,0.025)", e.shadowBlur = 30 * o.mousePower), e.globalAlpha = .95 * o.fadeInProgress, e.textBaseline = o.text.baseLine, e.fillStyle = cfg.bgColor, e.font = o.text.font; const a = o.text.value, s = doc.width / 2 - e.measureText(a).width / 2, l = 1.75 * t; e.fillText(a, s, l) })); for (let t = 0; t < o.textPixelData.length; t++) { const n = o.textPixelData[t], { x: i, y: r, value: c } = n, d = (3 + 50 * s) * Math.sin(a * t), h = (10 + 50 * s) * Math.cos(a * t), p = t / l * (1 - s); tools.drawPath(e, (() => { p && (e.globalAlpha = o.fadeInProgress, e.font = "8px Montserrat", e.fillStyle = `rgba(255,255,255,${.3 * p})`, t % 2 == 0 && e.fillText(c + "", i, r + -1 * h), e.fillStyle = `rgba(255,255,255,${p})`, e.fillRect(i + d, r, 5 * p * (1 - s), 1), e.fillRect(i, r + h, 1, 5 * p * (1 - s))) })) } } draw() { context.main; const t = this.state, { xCell: e, yCell: o, xCenter: a, yCenter: s, cells: l } = plane, n = t.planeProgress; this.state.planeProgress >= 1 && !t.planeIsDrawn && (t.planeIsDrawn = !0, this.startGeneratingGlitches(), this.startGeneratingLines(), this.startGeneratingNumbers(), this.getTextPixels(), this.animateText()), (!t.planeIsDrawn || t.dotsProgress < 1 || t.planeIsDrawn && t.needRedraw) && this.drawPlane(); for (let i = 0; i < l[0]; i++)for (let r = 0; r < l[1]; r++) { const l = i * e, c = r * o; t.planeIsDrawn && (this.drawMouseMoveInteraction({ i: i, i2: r, x: l, y: c }), r === a && i !== s && this.drawMarkupYAnimation({ i: i, i2: r, x: l, y: c, cp: n }), r !== a && i === s && this.drawMarkupXAnimation({ i: i, i2: r, x: l, y: c, cp: n })) } t.planeIsDrawn && (this.drawGlitches(), this.drawAnimLines(), this.drawNumbersAnimation(), this.drawText()) } startGeneratingNumbers() { const t = this.state; !function e() { const { cells: o, xCell: a, yCell: s } = plane, l = t.mousePower, n = tools.random(1 + 50 * (1 - l), 5 + 100 * (1 - l)) / t.area, i = { p: 0, color: `rgba(255,255,255,${tools.random(.01, .3)})`, blinks: Array(tools.random(0, 3, !0)).fill(null).map((t => ({ at: tools.random(0, 1), dur: tools.random(0, .3) }))), pf: tools.random(75e-5, .01), x: tools.random(0, o[0], !0) * a, y: tools.random(0, o[1], !0) * s, value: tools.random(0, 1, !0) }; t.tabIsActive && t.animNumbers.push(i), setTimeout(e, n) }() } drawNumbersAnimation() { const t = context.main, e = this.state, { yCell: o, xCell: a } = plane; e.animNumbers.forEach(((s, l) => { s.p += s.pf * e.delta; let n = !0; s.blinks.forEach((t => { s.p >= t.at && s.p <= t.at + t.dur && (n = !1) })), n && (tools.drawPath(t, (() => { cfg.shadowBlur && (t.shadowColor = "white", t.shadowBlur = 10), t.globalAlpha = e.fadeInProgress, t.textBaseline = "top", t.font = "18px Montserrat"; const l = parseInt(t.font) || 18, n = t.measureText(s.value + "").width; t.fillStyle = s.color, t.fillText(s.value + "", s.x + a / 2 - n / 2, s.y + o / 2 - l / 2) })), s.p >= 1 && e.animNumbers.splice(l, 1)) })) } startGeneratingLines() { const t = this.state; !function e() { const { cells: o, xCell: a, yCell: s } = plane, l = t.mousePower, n = tools.random(25 + 80 * (1 - l), 75 + 1200 * (1 - l)) / t.area, i = { p: 0, color: tools.random(0, .15), pf: tools.random(5e-4, .00125), x: tools.random(0, o[0], !0) * a, y: tools.random(0, o[1], !0) * s }; i.coord = tools.random(0, 1, !0) ? "x" : "y", i.length = tools.random(2 * a, t.area * a * 5), i.dir = tools.random(0, 1, !0) ? 1 : -1, i.distance = i.length * tools.random(1, 2), t.tabIsActive && t.animLines.push(i), setTimeout(e, n) }() } drawAnimLines() { const t = context.main, e = this.state; e.animLines.forEach(((o, a) => { o.p += o.pf * e.delta; const s = tools.easing(o.p, 0, 1, 1), l = s / .5, n = 1 - (s - .5) / .5, i = `rgba(255,255,255,${.1 + o.color * (s <= .5 ? l : n)})`, r = s <= .5 ? o.length * l : o.length * n, c = -1 === o.dir, d = "x" === o.coord, h = "y" === o.coord, p = d ? c ? -(r - o.distance * s) : -o.distance * s : 0, g = h ? c ? -(r - o.distance * s) : -o.distance * s : 0; tools.drawPath(t, (() => { t.globalAlpha = e.fadeInProgress, t.fillStyle = i, t.fillRect(o.x + p + (d && s <= .5 ? (o.length - r) * o.dir : 0), o.y + g + (h && s <= .5 ? (o.length - r) * o.dir : 0), d ? r : 1, h ? r : 1) })), o.p >= 1 && e.animLines.splice(a, 1) })) } startGeneratingGlitches() { const t = this.state; !function e() { const { cells: o, xCell: a, yCell: s } = plane, l = t.mousePower, n = tools.random((5 + 100 * (1 - l)) / t.area, (25 + 1200 * (1 - l)) / t.area), i = { p: 0, color: `rgba(255,255,255,${tools.random(.01, 1)})`, blinks: Array(tools.random(0, 3, !0)).fill(null).map((t => ({ at: tools.random(0, 1), dur: tools.random(0, .3) }))), pf: tools.random(.0015, .0035), x: tools.random(0, o[0], !0) * a, y: tools.random(0, o[1], !0) * s, width: a, height: s }; t.tabIsActive && t.glitches.push(i), setTimeout(e, n) }() } drawGlitches() { const t = context.main, e = this.state; e.glitches.forEach(((o, a) => { o.p += o.pf * e.delta; let s = !0; o.blinks.forEach((t => { o.p >= t.at && o.p <= t.at + t.dur && (s = !1) })), s && (tools.drawPath(t, (() => { cfg.shadowBlur && (t.shadowColor = "white", t.shadowBlur = 30), t.globalAlpha = e.fadeInProgress, t.fillStyle = o.color, t.fillRect(o.x, o.y, o.width, o.height) })), o.p >= 1 && e.glitches.splice(a, 1)) })) } drawMouseMoveInteraction(t) { const e = context.main, o = this.state, a = o.fadeInProgress, s = o.stepOffset, l = o.mousePower, { xCenter: n, yCenter: i } = plane, { i: r, i2: c, x: d, y: h } = t, p = [Math.abs(c - n), Math.abs(r - i)], g = r * c % 2 * (200 + 50 * l) * Math.sin(p[0] - p[1]); if (g <= 100) return; const m = tools.getVectorLength([d, h], [mouse.x, mouse.y]); if (m <= g) { const t = (1 - m / g) * a, o = 50 * (1 - t), l = Math.sin(s + r) * o * (2 * Math.PI / 4) * ((r + c) % 4 == 0 ? -1 : 1), n = Math.cos(s + c) * o * (2 * Math.PI / 4), i = d + l, p = h + n, f = 25 * (1 - t), u = 3 + 10 * t, x = tools.getVectorLength([i, p], [mouse.x, mouse.y]), w = `rgba(255,255,255,${.3 * t})`, P = `rgba(255,255,255,${.7 * (1 - x / (g + 2 * o)) * t})`; tools.drawPath(e, (() => { e.strokeStyle = P, e.moveTo(i, p), e.lineTo(mouse.x, mouse.y), e.stroke() })), tools.drawPath(e, (() => { e.strokeStyle = P, e.moveTo(d, h), e.lineTo(i, p), e.stroke() })), tools.drawPath(e, (() => { e.fillStyle = w, e.arc(d, h, 1, 0, 2 * Math.PI), e.fill() })), tools.drawPath(e, (() => { e.strokeStyle = `rgba(255,255,255,${.5 * t})`, e.lineWidth = 1 + 2 * (1 - t), e.arc(d, h, 3 + 10 * (1 - t), 0, 2 * Math.PI), e.stroke() })), tools.drawPath(e, (() => { e.fillStyle = `rgba(255,255,255,${t})`, e.arc(i, p, 1, 0, 2 * Math.PI), e.fill() })), tools.drawPath(e, (() => { cfg.shadowBlur && (e.shadowColor = "white", e.shadowBlur = f), e.lineWidth = u, e.strokeStyle = `rgba(255,255,255,${.75 * t})`, e.arc(i, p, f, 0, 2 * Math.PI), e.stroke() })) } } drawPlaneDotsAnimation(t) { const e = context.plane, { dp: o, i: a, i2: s, x: l, y: n } = t, { xCenter: i, yCenter: r } = plane, c = [Math.abs(s - i), Math.abs(a - r)]; let d = o * (o / (1 / (i * r) * (c[0] * c[1]))); d >= 1 && (d = 1); const h = d >= .5 ? (1 - d) / .5 : d / .5; h && tools.drawPath(e, (() => { e.fillStyle = `rgba(255,255,255,${.15 * h})`, e.fillRect(l - 1, n - 1, 3, 3) })) } drawPlaneCenterLines(t) { const { p: e } = t, o = context.plane, { centerCoords: a } = plane; tools.drawPath(o, (() => { o.fillStyle = `rgba(255,255,255,${.2 + 1 * (1 - e)})`, o.fillRect(a[0], 0 + doc.height / 2 * (1 - e), 1, doc.height * e), o.fillRect(0 + doc.width / 2 * (1 - e), a[1], doc.width * e, 1) })) } drawYLines(t) { const { i: e, cp: o, p: a, x: s } = t, l = context.plane, { yCenter: n } = plane; let i = o * (o / (1 / n * Math.abs(e - n))); i >= 1 && (i = 1); const r = tools.cellEasing(i, 0, 1, 1); e && tools.drawPath(l, (() => { l.fillStyle = `rgba(255,255,255,${.05 + .35 * (1 - a)})`, l.fillRect(s, 0 + doc.height / 2 * (1 - r), 1, doc.height * r) })) } drawYMarkup(t) { const e = context.plane; this.state; let { i: o, p: a, cp: s, x: l, y: n } = t; const { yCenter: i } = plane, r = 1 / i, c = r * Math.abs(o - i), d = [a >= c, a <= c + r]; let h = s * (s / c); h >= 1 && (h = 1); const p = d[0] && d[1] ? (a - c) / r : d[0] ? 1 : 0, g = o - i + ""; e.fillStyle = `rgba(255,255,255,${.1 + .75 * (1 - h)})`; const m = [l - e.measureText(g).width / 2, n + cfg.sectionWidth / 2 + cfg.numberOffset]; tools.drawPath(e, (() => { const t = 50 * (1 - p); e.globalAlpha = p, e.fillRect(l, n - cfg.sectionWidth / 2 + t, cfg.sectionHeight, cfg.sectionWidth) })), tools.drawPath(e, (() => { e.globalAlpha = p, e.textBaseline = "top", e.fillText(g, m[0], m[1] + -20 * (1 - p)) })) } drawXLines(t) { const e = context.plane, { i2: o, cp: a, p: s, y: l } = t, { xCenter: n } = plane; let i = a * (a / (1 / n * Math.abs(o - n))); i >= 1 && (i = 1); const r = tools.cellEasing(i, 0, 1, 1); o && tools.drawPath(e, (() => { e.fillStyle = `rgba(255,255,255,${.05 + .35 * (1 - s)})`, e.fillRect(0 + doc.width / 2 * (1 - r), l, doc.width * r, 1) })) } drawXMarkup(t) { const e = context.plane; this.state; let { i2: o, p: a, cp: s, x: l, y: n } = t; const { xCenter: i } = plane, r = 1 / i, c = r * Math.abs(o - i), d = [a >= c, a <= c + r]; let h = s * (s / c); h >= 1 && (h = 1); let p = d[0] && d[1] ? (a - c) / r : d[0] ? 1 : 0; e.fillStyle = `rgba(255,255,255,${.1 + .75 * (1 - h)})`, tools.drawPath(e, (() => { const t = 50 * (1 - p); e.globalAlpha = p, e.fillRect(l - cfg.sectionWidth / 2 + t, n, cfg.sectionWidth, cfg.sectionHeight) })), tools.drawPath(e, (() => { e.globalAlpha = p, e.textBaseline = "middle"; const t = [l + cfg.sectionWidth / 2 + cfg.numberOffset, n + cfg.sectionHeight / 2]; e.fillText(i - o + "", t[0] + -20 * (1 - p), t[1]) })) } drawPlane() { const t = this.state; context.plane.clearRect(0, 0, doc.width, doc.height); const { xCell: e, yCell: o, xCenter: a, yCenter: s, cells: l } = plane, n = tools.easing(t.planeProgress, 0, 1, 1), i = t.planeProgress, r = t.dotsProgress; this.drawPlaneCenterLines({ p: n }); for (let t = 0; t < l[0]; t++)for (let c = 0; c < l[1]; c++) { const l = t * e, d = c * o; t !== s && c !== a && this.drawPlaneDotsAnimation({ dp: r, i: t, i2: c, x: l, y: d }), c === a && t !== s && (this.drawYLines({ i: t, i2: c, p: n, cp: i, x: l, y: d }), this.drawYMarkup({ i: t, p: n, cp: i, x: l, y: d })), c !== a && t === s && (this.drawXLines({ i: t, i2: c, p: n, cp: i, x: l, y: d }), this.drawXMarkup({ i2: c, p: n, cp: i, x: l, y: d })) } } drawMarkupYAnimation(t) { const e = context.main, { yCenter: o } = plane, { i: a, x: s, y: l } = t, n = this.state, i = Math.sin(n.markupOffset), r = i >= 0 ? tools.cellEasing(Math.abs(i), 0, 1, 1) : 0, c = 1 / o, d = c * Math.abs(a - o), h = r >= d && r <= d + c ? (r - d) / c : 0; if (!h) return; const p = a - o + ""; e.fillStyle = `rgba(255,255,255,${.1 + .75 * (1 - h)})`; const g = [s - e.measureText(p).width / 2, l + cfg.sectionWidth / 2 + cfg.numberOffset]; tools.drawPath(e, (() => { e.fillStyle = `rgba(255,255,255,${.5 * h})`, e.fillRect(s, l - cfg.sectionWidth / 2, cfg.sectionHeight, cfg.sectionWidth) })), tools.drawPath(e, (() => { cfg.shadowBlur && (e.shadowBlur = 5, e.shadowColor = "white"), e.fillStyle = `rgba(255,255,255,${.35 * h})`, e.textBaseline = "top", e.fillText(p, g[0], g[1]) })) } drawMarkupXAnimation(t) { const e = context.main, o = this.state; let { i2: a, x: s, y: l } = t; const n = Math.sin(o.markupOffset), i = n <= 0 ? tools.cellEasing(Math.abs(n), 0, 1, 1) : 0, { xCenter: r } = plane, c = 1 / r, d = c * Math.abs(a - r), h = i >= d && i <= d + c ? (i - d) / c : 0; h && (tools.drawPath(e, (() => { e.fillStyle = `rgba(255,255,255,${.5 * h})`, e.fillRect(s - cfg.sectionWidth / 2, l, cfg.sectionWidth, cfg.sectionHeight) })), tools.drawPath(e, (() => { cfg.shadowBlur && (e.shadowBlur = 5, e.shadowColor = "white"), e.fillStyle = `rgba(255,255,255,${.3 * h})`, e.textBaseline = "middle"; const t = [s + cfg.sectionWidth / 2 + cfg.numberOffset, l + cfg.sectionHeight / 2]; e.fillText(r - a + "", t[0], t[1]) }))) } } window.addEventListener("load", (() => { window.app = new App }));